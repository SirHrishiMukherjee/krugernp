<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simulonic ⇄ Infosophic • Canvas Lab + Lens + Dynamic Pareto</title>
<style>
  :root{
    --bg:#0f1115; --panel:#161a22; --card:#1c2230; --text:#e8eef7; --muted:#9bb0c8;
    --accent:#61dafb; --good:#6ee7a6; --warn:#fbbf24; --grid:#2a3242; --hl:#9f7aea; --bad:#f87171;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#0c0f14,#0f1115); color:var(--text); font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;}
  header{
    position:sticky; top:0; z-index:10; display:flex; align-items:center; justify-content:space-between;
    padding:12px 16px; border-bottom:1px solid #202636; background:rgba(22,26,34,.85); backdrop-filter: blur(6px);
  }
  .brand{display:flex; gap:10px; align-items:center}
  .logo{width:36px; height:36px; border-radius:10px; background:radial-gradient(circle at 30% 30%, #7cfcff, #4c50ff 45%, #1f1340 70%); box-shadow:0 0 24px rgba(97,218,251,.35), inset 0 0 18px rgba(255,255,255,.12);}
  .title{font-weight:700}
  .sub{font-size:12px; color:var(--muted)}
  #stageWrap{position:relative; width:100%; height:calc(100vh - 64px);}
  canvas{display:block; width:100%; height:100%; background:linear-gradient(180deg,#121622,#0f121c);}

  .panel{
    position:absolute; top:12px; left:12px; width:360px; max-width:calc(100% - 24px); border:1px solid #232a3a; background:rgba(22,26,34,.9);
    border-radius:14px; padding:12px; box-shadow:0 10px 30px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.02);
  }
  .panel .h{font-size:12px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted); margin:2px 0 8px;}
  .row{display:flex; gap:10px; align-items:center; margin:8px 0}
  .row input[type="range"]{flex:1}
  .btn{
    padding:7px 10px; background:var(--card); border:1px solid #2a3147; color:var(--text); border-radius:10px; cursor:pointer; font-size:13px;
  }
  .btn:hover{border-color:#3a425e}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:12px}
  textarea.code{
    width:100%; min-height:150px; resize:vertical; border:1px solid #283048; border-radius:12px; background:#151a26; color:#e8eef7; padding:10px; outline:none;
  }
  .legend{
    position:absolute; right:12px; top:12px; background:rgba(16,20,30,.78); padding:8px 10px; border:1px solid #27304a; border-radius:10px; font-size:12px;
  }
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; margin:2px 2px; border:1px solid #2a3250}
  .pill.blue{background:rgba(97,218,251,.12); color:#bdefff}
  .pill.green{background:rgba(110,231,166,.12); color:#c7f8de}
  .pill.purple{background:rgba(159,122,234,.12); color:#e1d1ff}
  .pill.gold{background:rgba(251,191,36,.12); color:#ffe3a3}
  .pill.pos{background:rgba(110,231,166,.12); color:#bdf8dc; border-color:#245c41}
  .pill.neg{background:rgba(248,113,113,.12); color:#ffd1d1; border-color:#5c2424}

  .stats{
    position:absolute; right:12px; bottom:12px; background:rgba(16,20,30,.78); padding:10px; border:1px solid #27304a; border-radius:10px; font-size:12px;
  }
  .statLine{display:flex; justify-content:space-between; gap:12px; margin:4px 0}
  .muted{color:var(--muted)}

  .outlookGrid{
    display:grid; grid-template-columns: 1fr auto; gap:6px; background:rgba(21,26,38,.7);
    border:1px solid #27304a; border-radius:10px; padding:8px; margin:8px 0;
  }
  .toggle{
    padding:4px 8px; border-radius:999px; border:1px solid #2a3147; cursor:pointer; font-size:12px;
    background:linear-gradient(180deg, #1f2a44, #1a2440);
  }
  .toggle.pos{border-color:#2b6b54}
  .toggle.neg{border-color:#6b2b2b}
  .swatch{display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:middle}
  .note{font-size:11px; color:var(--muted); margin-top:6px; line-height:1.35}

  .lensHUD{
    position:absolute; left:50%; transform:translateX(-50%); bottom:12px;
    background:rgba(16,20,30,.78); padding:8px 10px; border:1px solid #27304a; border-radius:10px; font-size:12px;
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
  }
  .chk{display:flex; align-items:center; gap:8px; font-size:12px}
</style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo" title="Simulonic ⇄ Infosophic"></div>
      <div>
        <div class="title">Simulonic ⇄ Infosophic • Canvas Lab</div>
        <div class="sub">Dual gauges for ds² • SimuLang • ART t-distribution • Lens • Dynamic Pareto</div>
      </div>
    </div>
    <div class="sub">Infosophic: Gösta Greimel • Simulonic: Hrishi Mukherjee • Integration: Greimel & Mukherjee • OBT: Oliver Boeschenstein</div>
  </header>

  <div id="stageWrap">
    <canvas id="stage"></canvas>

    <!-- Controls -->
    <div class="panel" id="ctrlPanel">
      <div class="h">Controls</div>
      <div class="row"><span class="muted">Pareto τ</span><input id="rngTau" type="range" min="0.05" max="1.5" step="0.01"><span class="mono" id="labTau"></span></div>
      <div class="row chk">
        <input id="chkAutoPareto" type="checkbox" />
        <label for="chkAutoPareto">Auto Pareto (keep head ≈ 20% for target mass)</label>
      </div>
      <div class="row"><span class="muted">Target head mass</span><input id="rngTargetMass" type="range" min="0.50" max="0.95" step="0.01" style="flex:1"><span class="mono" id="labTargetMass"></span></div>

      <div class="row"><span class="muted">Quality Q</span><input id="rngQ" type="range" min="0.5" max="3" step="0.05"><span class="mono" id="labQ"></span></div>
      <div class="row"><span class="muted">Intent</span>
        <select id="selAxis" class="btn">
          <option value="radial">radial</option><option value="x">x</option><option value="y">y</option>
        </select>
        <span class="muted">Strength</span><input id="rngIntent" type="range" min="0" max="3" step="0.05" style="flex:1"><span class="mono" id="labIntent"></span>
      </div>
      <div class="row"><span class="muted">ART ν</span><input id="rngNu" type="range" min="1" max="12" step="1"><span class="mono" id="labNu"></span></div>
      <div class="row"><span class="muted">Points</span><input id="rngPts" type="range" min="60" max="1500" step="10"><span class="mono" id="labPts"></span></div>
      <div class="row"><span class="muted">Mood Strength</span><input id="rngMood" type="range" min="0" max="2" step="0.05" style="flex:1"><span class="mono" id="labMood"></span></div>
      <div class="row">
        <button class="btn" id="btnShuffle">Shuffle Seed</button>
        <button class="btn" id="btnClear">Clear Lock-ons</button>
      </div>

      <div class="h">Outlooks (per dimension)</div>
      <div id="outlookGrid" class="outlookGrid"></div>
      <div class="note">Tags are simulation labels only—abstract categories to test dynamics. No real-world judgments are implied.</div>

      <div class="h">SimuLang Hook (mini)</div>
      <textarea id="simTxt" class="code mono" spellcheck="false"></textarea>
      <div class="row">
        <button class="btn" id="btnApply">Apply</button>
        <button class="btn" id="btnReset">Reset</button>
      </div>
      <div class="mono muted">pareto.tau=0.55 • quality.q=1.00 • intent.axis=radial|x|y • intent.strength=1.20 • art.nu=3 • art.points=260 • lockon.k=6 • mood.strength=1.0</div>
    </div>

    <div class="legend">
      <span class="pill blue">ART t-field</span>
      <span class="pill green">Lock-on</span>
      <span class="pill purple">Infosophic ⇄ Simulonic</span>
      <span class="pill gold">ds² gauges</span>
      <span class="pill pos">Optimistic</span>
      <span class="pill neg">Pessimistic</span>
    </div>

    <div class="stats" id="statsBox">
      <div class="statLine"><span class="muted">ds² (Green)</span><span class="mono" id="statG">0.000</span></div>
      <div class="statLine"><span class="muted">ds² (Vacuum)</span><span class="mono" id="statV">0.000</span></div>
      <div class="statLine"><span class="muted">Locked</span><span class="mono" id="statL">0</span></div>
      <div class="statLine"><span class="muted">Pareto τ</span><span class="mono" id="statT">0.00</span></div>
      <div class="statLine"><span class="muted">Head k/N</span><span class="mono" id="statK">0/0</span></div>
      <div class="statLine"><span class="muted">Head mass</span><span class="mono" id="statMass">0.00</span></div>
      <div class="statLine"><span class="muted">Optimistic</span><span class="mono" id="statPos">0</span></div>
      <div class="statLine"><span class="muted">Pessimistic</span><span class="mono" id="statNeg">0</span></div>
    </div>

    <!-- Lens HUD -->
    <div class="lensHUD">
      <button class="btn" id="btnLensMode">Lens: Infosophic (I)</button>
      <span class="muted">Radius</span>
      <input id="rngLensR" type="range" min="60" max="360" step="2" style="width:220px">
      <span class="mono" id="labLensR">180</span>
      <span class="muted">Drag the circle • Press S to switch to Simulonic</span>
    </div>
  </div>

<script>
/* ---------- Sizing ---------- */
const stage = document.getElementById('stage');
const wrap = document.getElementById('stageWrap');
function fitCanvas(){
  const headerH = document.querySelector('header').offsetHeight || 64;
  wrap.style.height = `calc(100vh - ${headerH}px)`;
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  stage.width = Math.floor(wrap.clientWidth * dpr);
  stage.height = Math.floor(wrap.clientHeight * dpr);
  stage.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ---------- RNG + math ---------- */
function rng(seed){ let t = seed>>>0; return ()=>{ t += 0x6D2B79F5; let r = Math.imul(t ^ (t>>>15), 1|t); r ^= r + Math.imul(r ^ (r>>>7), 61|r); return ((r ^ (r>>>14))>>>0)/4294967296; }; }
function randn(r){ let u=1-r(), v=1-r(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function chiSquare(df, r){ let s=0; for(let i=0;i<df;i++){ const z=randn(r); s += z*z; } return s; }
function studentT(df, r){ const z=randn(r); return z / Math.sqrt(chiSquare(df,r)/df); }
function softmax(arr, temp=1){ const m=Math.max(...arr); const ex=arr.map(v=>Math.exp((v-m)/Math.max(1e-6,temp))); const s=ex.reduce((a,b)=>a+b,0); return ex.map(e=>e/s); }

/* ---------- SimuLang ---------- */
const defaultSimuLang = `# SimuLang mini-hook
pareto.tau = 0.55
quality.q = 1.00
intent.axis = radial
intent.strength = 1.20
art.nu = 3
art.points = 260
lockon.k = 6
mood.strength = 1.0
`;
function parseSimuLang(src){
  const cfg = { paretoTau:0.55, qualityQ:1.0, intentAxis:'radial', intentStrength:1.2, artNu:3, artPoints:260, lockTopK:6, moodStrength:1.0, autoPareto:false, targetMass:0.80 };
  const lines = src.split('\n').map(s=>s.trim()).filter(Boolean);
  for(const l of lines){
    const m = l.match(/^([a-z.]+)\s*=\s*([^\#]+)(?:\#.*)?$/i); if(!m) continue;
    const k=m[1].toLowerCase().trim(), v=m[2].trim();
    if(k==='pareto.tau') cfg.paretoTau = parseFloat(v);
    if(k==='quality.q') cfg.qualityQ = parseFloat(v);
    if(k==='intent.axis') cfg.intentAxis = (''+v).toLowerCase();
    if(k==='intent.strength') cfg.intentStrength = parseFloat(v);
    if(k==='art.nu') cfg.artNu = Math.max(1, parseInt(v));
    if(k==='art.points') cfg.artPoints = Math.max(10, Math.min(5000, parseInt(v)));
    if(k==='lockon.k') cfg.lockTopK = Math.max(0, parseInt(v));
    if(k==='mood.strength') cfg.moodStrength = Math.max(0, parseFloat(v));
    if(k==='auto.pareto') cfg.autoPareto = (''+v).toLowerCase().trim() === 'true';
    if(k==='target.mass') cfg.targetMass = Math.min(0.95, Math.max(0.5, parseFloat(v)));
  }
  return cfg;
}

/* ---------- Outlooks ---------- */
const DIMENSIONS = ['Creed','Race','Class','Caste','Tribe','Nationality','Continentality','Planetarity','Occupation'];
let outlook = Object.fromEntries(DIMENSIONS.map(d => [d, +1]));
function hueForDim(i){ return (i*37)%360; }

/* ---------- State ---------- */
let seed = 42;
let cfg = parseSimuLang(defaultSimuLang);
let lockSet = new Set();
let points=[], weights=[];
const ctx = stage.getContext('2d');

/* ---------- Elements ---------- */
const E = {
  tau: rngTau, q: rngQ, intent: rngIntent, axis: selAxis, nu: rngNu, pts: rngPts, mood: rngMood,
  labTau, labQ, labIntent, labNu, labPts, labMood,
  statG, statV, statL, statT, statPos, statNeg, statK, statMass,
  simTxt: simTxt, btnApply, btnReset, btnShuffle, btnClear,
  outlookGrid: outlookGrid,
  btnLensMode: btnLensMode, rngLensR: rngLensR, labLensR: labLensR,
  chkAutoPareto: chkAutoPareto, rngTargetMass: rngTargetMass, labTargetMass: labTargetMass
};
E.simTxt.value = defaultSimuLang;

/* ---------- Lens ---------- */
const lens = { x: stage.clientWidth/2, y: stage.clientHeight/2, r: 180, mode: 'infosophic', dragging:false, offsetX:0, offsetY:0 };
rngLensR.value = lens.r; labLensR.textContent = lens.r;
function setLensMode(next){ lens.mode = next; btnLensMode.textContent = next==='infosophic' ? 'Lens: Infosophic (I)' : 'Lens: Simulonic (S)'; }
btnLensMode.addEventListener('click', ()=> setLensMode(lens.mode==='infosophic' ? 'simulonic' : 'infosophic'));
document.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='i') setLensMode('infosophic'); if(e.key.toLowerCase()==='s') setLensMode('simulonic'); });
rngLensR.addEventListener('input', (e)=>{ lens.r = parseInt(e.target.value,10); labLensR.textContent = lens.r; });
stage.addEventListener('mousedown', (e)=>{ const r=stage.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; const dx=x-lens.x, dy=y-lens.y; if(Math.hypot(dx,dy)<=lens.r){ lens.dragging=true; lens.offsetX=dx; lens.offsetY=dy; }});
window.addEventListener('mouseup', ()=>{ lens.dragging=false; });
window.addEventListener('mousemove', (e)=>{ if(!lens.dragging) return; const r=stage.getBoundingClientRect(); lens.x = e.clientX-r.left - lens.offsetX; lens.y = e.clientY-r.top - lens.offsetY; });

/* ---------- UI wiring ---------- */
function syncControls(){
  E.tau.value = cfg.paretoTau; E.labTau.textContent = cfg.paretoTau.toFixed(2);
  E.chkAutoPareto.checked = cfg.autoPareto;
  E.rngTargetMass.value = cfg.targetMass; E.labTargetMass.textContent = cfg.targetMass.toFixed(2);
  E.q.value = cfg.qualityQ; E.labQ.textContent = cfg.qualityQ.toFixed(2);
  E.intent.value = cfg.intentStrength; E.labIntent.textContent = cfg.intentStrength.toFixed(2);
  E.axis.value = cfg.intentAxis;
  E.nu.value = cfg.artNu; E.labNu.textContent = cfg.artNu;
  E.pts.value = cfg.artPoints; E.labPts.textContent = cfg.artPoints;
  E.mood.value = cfg.moodStrength; E.labMood.textContent = cfg.moodStrength.toFixed(2);
  E.statT.textContent = cfg.paretoTau.toFixed(2);
}
syncControls();

function buildOutlookGrid(){
  outlookGrid.innerHTML = '';
  DIMENSIONS.forEach((d,i)=>{
    const label = document.createElement('div');
    const sw = document.createElement('span'); sw.className='swatch'; sw.style.background = `hsl(${hueForDim(i)} 80% 60%)`;
    label.appendChild(sw); label.appendChild(document.createTextNode(d));
    const btn = document.createElement('button'); const isPos = outlook[d]>=0;
    btn.className='toggle ' + (isPos?'pos':'neg'); btn.textContent=isPos?'Optimistic':'Pessimistic';
    btn.title = `Toggle outlook for ${d}`;
    btn.addEventListener('click', ()=>{ outlook[d]=(outlook[d]>=0)?-1:+1; buildOutlookGrid(); buildART(); });
    outlookGrid.appendChild(label); outlookGrid.appendChild(btn);
  });
}
buildOutlookGrid();

/* ---------- Field generation ---------- */
function buildART(){
  const r = rng(seed);
  const W=stage.clientWidth, H=stage.clientHeight, cx=W/2, cy=H/2, scale=Math.min(W,H)*0.33;
  points=[]; let pos=0, neg=0;
  for(let i=0;i<cfg.artPoints;i++){
    const dim = DIMENSIONS[i % DIMENSIONS.length];
    const tx=studentT(cfg.artNu,r), ty=studentT(cfg.artNu,r);
    const x=cx+scale*tx, y=cy+scale*ty;
    const dx=x-cx, dy=y-cy, rad=Math.hypot(dx,dy)/(scale+1e-6);
    let align=0; if(cfg.intentAxis==='x') align=Math.abs(dx)/(scale+1e-6); else if(cfg.intentAxis==='y') align=Math.abs(dy)/(scale+1e-6); else align=Math.max(0,1-rad);
    const base = 1/(1 + (dx*dx+dy*dy)/(scale*scale));
    const mood = outlook[dim]||+1;
    const moodGain = 1 + cfg.moodStrength*(mood*0.25);
    const sal = base * (1 + cfg.intentStrength*align) * moodGain;
    if(mood>=0) pos++; else neg++;
    points.push({x,y,sal,dim,mood});
  }
  const maxS = points.reduce((m,p)=>Math.max(m,p.sal),1e-6);
  for(const p of points){ p.sal/=maxS; }
  recomputeWeights(); // uses cfg.paretoTau
  if(cfg.lockTopK>0){
    const top=[...points.map((p,i)=>[p.sal,i])].sort((a,b)=>b[0]-a[0]).slice(0,cfg.lockTopK).map(x=>x[1]);
    for(const i of top) lockSet.add(i);
  }
  E.statPos.textContent = pos; E.statNeg.textContent = neg;
}
function recomputeWeights(){
  weights = softmax(points.map(p=>p.sal), Math.max(0.05,cfg.paretoTau));
}

/* ---------- Dynamic Pareto control ---------- */
function headStatsForTarget(targetMass){
  // Sort weights desc; find smallest k with cumulative mass ≥ targetMass
  const arr = weights.map((w,i)=>[w,i]).sort((a,b)=>b[0]-a[0]);
  let cum=0, k=0;
  for(k=0;k<arr.length;k++){ cum += arr[k][0]; if(cum>=targetMass) break; }
  const headFrac = (k+1)/Math.max(1,weights.length);
  return {k: k+1, headFrac, mass: cum};
}
function autoAdjustTau(dtSec){
  // target: headFrac ≈ 0.20 (for default 80/20), but computed from targetMass so we don't hardcode 0.20
  const targetMass = cfg.targetMass; // e.g., 0.80
  const {headFrac} = headStatsForTarget(targetMass);
  const targetHeadFrac = 0.20; // can also be made a slider if you want
  const error = headFrac - targetHeadFrac; // positive => head too large -> decrease τ to sharpen
  const gain = 1.0; // base gain
  const step = -gain * error * dtSec; // negative error increases τ (softer); positive error decreases τ (sharper)
  cfg.paretoTau = Math.min(1.5, Math.max(0.05, cfg.paretoTau + step));
  // re-sync labels and slider
  E.tau.value = cfg.paretoTau; E.labTau.textContent = cfg.paretoTau.toFixed(2); E.statT.textContent = cfg.paretoTau.toFixed(2);
  // recompute weights with new τ
  recomputeWeights();
}

/* ---------- Gauges (global) ---------- */
function computeDS2Dual(lockedIdx){
  if(points.length===0) return {g:0,v:0};
  let active = lockedIdx.length ? lockedIdx : [...points.map((p,i)=>[p.sal,i])]
    .sort((a,b)=>b[0]-a[0]).slice(0, Math.max(3, Math.floor(points.length*0.05))).map(x=>x[1]);
  const K = (a,b)=>{ const dx=a.x-b.x, dy=a.y-b.y, d2=dx*dx+dy*dy; return Math.exp(-d2/3000); };
  const G = (a,b)=>{ const dx=a.x-b.x, dy=a.y-b.y; return 1/(Math.hypot(dx,dy)+1e-3); };
  const Qn = cfg.qualityQ;
  let dsG=0, dsV=0;
  for(const i of active){
    for(let j=0;j<points.length;j++){
      const wi=weights[i]/Qn, wj=weights[j]/Qn;
      dsG += wi*wj*K(points[i], points[j]);
      dsV += wi*wj*G(points[i], points[j]);
    }
  }
  const squash = v => 1 - Math.exp(-v/50);
  return { g: squash(dsG), v: squash(dsV) };
}

/* ---------- Lens helpers ---------- */
function lensScores(){
  const cx=lens.x, cy=lens.y, r=lens.r;
  const useK = (a)=>Math.exp(-((a.x-cx)**2 + (a.y-cy)**2)/3000);
  const useG = (a)=>1/(Math.hypot(a.x-cx, a.y-cy)+1e-3);
  const kernel = lens.mode==='infosophic' ? useK : useG;

  let scores = new Float32Array(points.length);
  let sum=0;
  for(let i=0;i<points.length;i++){
    const p=points[i]; const dx=p.x-cx, dy=p.y-cy; const inside=(dx*dx+dy*dy)<=r*r;
    if(!inside){ scores[i]=0; continue; }
    const s = (weights[i]/Math.max(0.5,cfg.qualityQ)) * kernel(p);
    scores[i]=s; sum+=s;
  }
  const maxScore = Math.max(1e-6, ...scores);
  for(let i=0;i<scores.length;i++) scores[i]/=maxScore;
  const dsLocal = 1 - Math.exp(-sum/20);
  return {scores, dsLocal};
}
function drawLensOverlay(scores){
  const r=lens.r, cx=lens.x, cy=lens.y;
  ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.clip();
  ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(cx-r-2, cy-r-2, r*2+4, r*2+4);
  for(let i=0;i<points.length;i++){
    const s=scores[i]; if(s<=0) continue; const p=points[i];
    const a=.25 + .55*s; const col = (lens.mode==='infosophic') ? `hsla(195, 90%, 60%, ${a})` : `hsla(40, 95%, 60%, ${a})`;
    ctx.beginPath(); ctx.fillStyle=col; ctx.arc(p.x,p.y, 2+3*s,0,Math.PI*2); ctx.fill();
  }
  const {dsLocal} = lensScores();
  ctx.strokeStyle = lens.mode==='infosophic' ? 'rgba(97,218,251,.9)' : 'rgba(251,191,36,.9)';
  ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(cx,cy, 40*(.6+.8*dsLocal), 40*(.6+.8*dsLocal), 0,0,Math.PI*2); ctx.stroke();
  ctx.restore();

  ctx.beginPath(); ctx.setLineDash([6,4]); ctx.lineWidth=2.2;
  ctx.strokeStyle = lens.mode==='infosophic' ? 'rgba(97,218,251,.9)' : 'rgba(251,191,36,.9)';
  ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]);

  ctx.fillStyle='rgba(16,20,30,.85)'; ctx.strokeStyle='#27304a'; ctx.lineWidth=1;
  const label = lens.mode==='infosophic' ? 'Infosophic lens (∇⁻¹)' : 'Simulonic lens (∇¹)⁻¹';
  const metrics = lensScores();
  const text = `${label} • r=${r} • local ds²=${metrics.dsLocal.toFixed(3)}`;
  ctx.font='12px ui-monospace'; const w=ctx.measureText(text).width+12, h=20;
  ctx.beginPath(); ctx.roundRect(cx - w/2, cy - r - 28, w, h, 6); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#cfe8ff'; ctx.fillText(text, cx - w/2 + 6, cy - r - 14);
}

/* ---------- Pareto bar overlay (runtime) ---------- */
function drawParetoBar(){
  if(weights.length===0) return;
  const x = 12, y = 12, W = 280, H = 44;
  ctx.save();
  ctx.fillStyle='rgba(16,20,30,.78)'; ctx.strokeStyle='#27304a'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.roundRect(x,y,W,H,10); ctx.fill(); ctx.stroke();

  // Sorted weights, cumulative
  const arr = weights.slice().sort((a,b)=>b-a);
  let cum=0; const target = cfg.targetMass;
  let kStar = arr.length;
  for(let i=0;i<arr.length;i++){ cum += arr[i]; if(cum>=target){ kStar=i+1; break; } }
  const headFrac = kStar/arr.length;
  const headW = Math.max(1, Math.floor(W*headFrac));

  // head area
  ctx.fillStyle='rgba(110,231,166,.35)'; ctx.fillRect(x+1, y+H-16, headW-2, 10);
  // tail area
  ctx.fillStyle='rgba(97,218,251,.25)'; ctx.fillRect(x+headW, y+H-16, W-headW-1, 10);

  // labels
  ctx.fillStyle='#cfe8ff'; ctx.font='12px ui-monospace';
  ctx.fillText(`Pareto (runtime) — τ=${cfg.paretoTau.toFixed(2)} • head ${kStar}/${arr.length} (${(headFrac*100).toFixed(1)}%) • mass ${Math.min(cum,1).toFixed(2)}`, x+8, y+16);
  ctx.restore();

  // stats panel mirrors
  E.statK.textContent = `${kStar}/${arr.length}`;
  E.statMass.textContent = Math.min(cum,1).toFixed(2);
}

/* ---------- Render loop ---------- */
let lastT = performance.now();
function render(tNow){
  const dtSec = Math.min(0.1, (tNow - lastT)/1000); lastT = tNow;

  // Auto Pareto control
  if(cfg.autoPareto && points.length>0){
    autoAdjustTau(dtSec); // adapts τ to maintain ~80/20 (or chosen mass)
  }

  const W=stage.clientWidth, H=stage.clientHeight;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='#0f131d'; ctx.fillRect(0,0,W,H);

  // grid
  ctx.strokeStyle='rgba(70,90,130,.35)'; ctx.lineWidth=1;
  const step=40;
  for(let x=0;x<W;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // global gauges
  const lockedIdx=[...lockSet];
  const ds=computeDS2Dual(lockedIdx);
  const cx=W/2, cy=H/2;
  ctx.strokeStyle='rgba(159,122,234,.85)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.ellipse(cx, cy, 120*(.6+.6*ds.g), 120*(.6+.6*ds.v), 0, 0, Math.PI*2); ctx.stroke();

  // points
  let posCount=0, negCount=0;
  for(let i=0;i<points.length;i++){
    const p=points[i];
    const w=weights[i]||0;
    const r=2+4*w;
    const locked=lockSet.has(i);
    const dimIdx = DIMENSIONS.indexOf(p.dim);
    const baseHue = (dimIdx*37)%360;
    const hue = (p.mood>=0)? (baseHue*0.7 + 120*0.3) : (baseHue*0.7 + 0*0.3);
    const alpha = 0.6 + 0.35*w;
    ctx.beginPath();
    ctx.fillStyle = locked ? `hsl(160 90% 60% / .95)` : `hsl(${hue} 80% 60% / ${alpha})`;
    ctx.strokeStyle = locked ? 'rgba(110,231,166,.85)' : (p.mood>=0 ? 'rgba(110,231,166,.35)' : 'rgba(248,113,113,.35)');
    ctx.lineWidth = locked ? 1.6 : 1;
    ctx.arc(p.x,p.y,r*(locked?1.3:1.0),0,Math.PI*2); ctx.fill(); ctx.stroke();
    if(locked){
      ctx.beginPath(); ctx.setLineDash([4,4]); ctx.strokeStyle='rgba(110,231,166,.3)';
      ctx.arc(p.x,p.y,r*2.0,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
    }
    if(p.mood>=0) posCount++; else negCount++;
  }

  // lens overlay
  const {scores} = lensScores();
  drawLensOverlay(scores);

  // dynamic Pareto bar (runtime)
  drawParetoBar();

  // stats
  E.statG.textContent = ds.g.toFixed(3);
  E.statV.textContent = ds.v.toFixed(3);
  E.statL.textContent = lockSet.size;
  E.statPos.textContent = posCount;
  E.statNeg.textContent = negCount;

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/* ---------- Interaction ---------- */
stage.addEventListener('click', (e)=>{
  const rect=stage.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  const inside = Math.hypot(x-lens.x, y-lens.y) <= lens.r; if(inside) return;
  let best=-1, bd=1e9;
  for(let i=0;i<points.length;i++){ const dx=points[i].x-x, dy=points[i].y-y, d=dx*dx+dy*dy; if(d<bd){ bd=d; best=i; } }
  if(best>=0){ if(lockSet.has(best)) lockSet.delete(best); else lockSet.add(best); }
});

/* ---------- Control events ---------- */
rngTau.addEventListener('input', e=>{ cfg.paretoTau=parseFloat(e.target.value); labTau.textContent=cfg.paretoTau.toFixed(2); statT.textContent=cfg.paretoTau.toFixed(2); recomputeWeights(); });
rngQ.addEventListener('input', e=>{ cfg.qualityQ=parseFloat(e.target.value); labQ.textContent=cfg.qualityQ.toFixed(2); });
rngIntent.addEventListener('input', e=>{ cfg.intentStrength=parseFloat(e.target.value); labIntent.textContent=cfg.intentStrength.toFixed(2); buildART(); });
selAxis.addEventListener('change', e=>{ cfg.intentAxis=e.target.value; buildART(); });
rngNu.addEventListener('input', e=>{ cfg.artNu=parseInt(e.target.value,10); labNu.textContent=cfg.artNu; buildART(); });
rngPts.addEventListener('input', e=>{ cfg.artPoints=parseInt(e.target.value,10); labPts.textContent=cfg.artPoints; lockSet.clear(); buildART(); });
rngMood.addEventListener('input', e=>{ cfg.moodStrength=parseFloat(e.target.value); labMood.textContent=cfg.moodStrength.toFixed(2); buildART(); });

btnShuffle.addEventListener('click', ()=>{ seed=(seed*1664525+1013904223)>>>0; lockSet.clear(); buildART(); });
btnClear.addEventListener('click', ()=>{ lockSet.clear(); });

btnApply.addEventListener('click', ()=>{ const parsed=parseSimuLang(simTxt.value); cfg={...cfg,...parsed}; syncControls(); lockSet.clear(); buildART(); });
btnReset.addEventListener('click', ()=>{ simTxt.value=defaultSimuLang; cfg=parseSimuLang(simTxt.value); syncControls(); lockSet.clear(); buildART(); });

chkAutoPareto.addEventListener('change', (e)=>{ cfg.autoPareto = e.target.checked; });
rngTargetMass.addEventListener('input', (e)=>{ cfg.targetMass = parseFloat(e.target.value); labTargetMass.textContent = cfg.targetMass.toFixed(2); });

/* ---------- First-time setup ---------- */
buildART();
labTargetMass.textContent = cfg.targetMass.toFixed(2);
</script>
</body>
</html>
