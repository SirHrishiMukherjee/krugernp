<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simulonic ⇄ Infosophic • Canvas Lab + Lens</title>
<style>
  :root{
    --bg:#0f1115; --panel:#161a22; --card:#1c2230; --text:#e8eef7; --muted:#9bb0c8;
    --accent:#61dafb; --good:#6ee7a6; --warn:#fbbf24; --grid:#2a3242; --hl:#9f7aea; --bad:#f87171;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#0c0f14,#0f1115); color:var(--text); font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;}
  header{
    position:sticky; top:0; z-index:10; display:flex; align-items:center; justify-content:space-between;
    padding:12px 16px; border-bottom:1px solid #202636; background:rgba(22,26,34,.85); backdrop-filter: blur(6px);
  }
  .brand{display:flex; gap:10px; align-items:center}
  .logo{width:36px; height:36px; border-radius:10px; background:radial-gradient(circle at 30% 30%, #7cfcff, #4c50ff 45%, #1f1340 70%); box-shadow:0 0 24px rgba(97,218,251,.35), inset 0 0 18px rgba(255,255,255,.12);}
  .title{font-weight:700}
  .sub{font-size:12px; color:var(--muted)}
  #stageWrap{position:relative; width:100%; height:calc(100vh - 64px);}
  canvas{display:block; width:100%; height:100%; background:linear-gradient(180deg,#121622,#0f121c);}

  .panel{
    position:absolute; top:12px; left:12px; width:360px; max-width:calc(100% - 24px); border:1px solid #232a3a; background:rgba(22,26,34,.9);
    border-radius:14px; padding:12px; box-shadow:0 10px 30px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.02);
  }
  .panel .h{font-size:12px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted); margin:2px 0 8px;}
  .row{display:flex; gap:10px; align-items:center; margin:8px 0}
  .row input[type="range"]{flex:1}
  .btn{
    padding:7px 10px; background:var(--card); border:1px solid #2a3147; color:var(--text); border-radius:10px; cursor:pointer; font-size:13px;
  }
  .btn:hover{border-color:#3a425e}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:12px}
  textarea.code{
    width:100%; min-height:150px; resize:vertical; border:1px solid #283048; border-radius:12px; background:#151a26; color:var(--text); padding:10px; outline:none;
  }
  .legend{
    position:absolute; right:12px; top:12px; background:rgba(16,20,30,.78); padding:8px 10px; border:1px solid #27304a; border-radius:10px; font-size:12px;
  }
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; margin:2px 2px; border:1px solid #2a3250}
  .pill.blue{background:rgba(97,218,251,.12); color:#bdefff}
  .pill.green{background:rgba(110,231,166,.12); color:#c7f8de}
  .pill.purple{background:rgba(159,122,234,.12); color:#e1d1ff}
  .pill.gold{background:rgba(251,191,36,.12); color:#ffe3a3}
  .pill.pos{background:rgba(110,231,166,.12); color:#bdf8dc; border-color:#245c41}
  .pill.neg{background:rgba(248,113,113,.12); color:#ffd1d1; border-color:#5c2424}

  .stats{
    position:absolute; right:12px; bottom:12px; background:rgba(16,20,30,.78); padding:10px; border:1px solid #27304a; border-radius:10px; font-size:12px;
  }
  .statLine{display:flex; justify-content:space-between; gap:12px; margin:4px 0}
  .muted{color:var(--muted)}

  .outlookGrid{
    display:grid; grid-template-columns: 1fr auto; gap:6px; background:rgba(21,26,38,.7);
    border:1px solid #27304a; border-radius:10px; padding:8px; margin:8px 0;
  }
  .toggle{
    padding:4px 8px; border-radius:999px; border:1px solid #2a3147; cursor:pointer; font-size:12px;
    background:linear-gradient(180deg, #1f2a44, #1a2440);
  }
  .toggle.pos{border-color:#2b6b54}
  .toggle.neg{border-color:#6b2b2b}
  .swatch{display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:middle}
  .note{font-size:11px; color:var(--muted); margin-top:6px; line-height:1.35}

  .lensHUD{
    position:absolute; left:50%; transform:translateX(-50%); bottom:12px;
    background:rgba(16,20,30,.78); padding:8px 10px; border:1px solid #27304a; border-radius:10px; font-size:12px;
    display:flex; gap:10px; align-items:center;
  }
</style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo" title="Simulonic ⇄ Infosophic"></div>
      <div>
        <div class="title">Simulonic ⇄ Infosophic • Canvas Lab</div>
        <div class="sub">Dual gauges for ds² • SimuLang hook • ART t-distribution lock-ons • Draggable Lens</div>
      </div>
    </div>
    <div class="sub">Infosophic: Gösta Greimel • Simulonic: Hrishi Mukherjee • Integration: Greimel & Mukherjee • OBT: Oliver Boeschenstein</div>
  </header>

  <div id="stageWrap">
    <canvas id="stage"></canvas>

    <!-- Controls -->
    <div class="panel" id="ctrlPanel">
      <div class="h">Controls</div>
      <div class="row"><span class="muted">Pareto τ</span><input id="rngTau" type="range" min="0.05" max="1.5" step="0.01"><span class="mono" id="labTau"></span></div>
      <div class="row"><span class="muted">Quality Q</span><input id="rngQ" type="range" min="0.5" max="3" step="0.05"><span class="mono" id="labQ"></span></div>
      <div class="row"><span class="muted">Intent</span>
        <select id="selAxis" class="btn">
          <option value="radial">radial</option><option value="x">x</option><option value="y">y</option>
        </select>
        <span class="muted">Strength</span><input id="rngIntent" type="range" min="0" max="3" step="0.05" style="flex:1"><span class="mono" id="labIntent"></span>
      </div>
      <div class="row"><span class="muted">ART ν</span><input id="rngNu" type="range" min="1" max="12" step="1"><span class="mono" id="labNu"></span></div>
      <div class="row"><span class="muted">Points</span><input id="rngPts" type="range" min="60" max="1500" step="10"><span class="mono" id="labPts"></span></div>
      <div class="row"><span class="muted">Mood Strength</span><input id="rngMood" type="range" min="0" max="2" step="0.05" style="flex:1"><span class="mono" id="labMood"></span></div>
      <div class="row">
        <button class="btn" id="btnShuffle">Shuffle Seed</button>
        <button class="btn" id="btnClear">Clear Lock-ons</button>
      </div>

      <div class="h">Outlooks (per dimension)</div>
      <div id="outlookGrid" class="outlookGrid"></div>
      <div class="note">Tags are simulation labels only—abstract categories to test dynamics. No real-world judgments are implied.</div>

      <div class="h">SimuLang Hook (mini)</div>
      <textarea id="simTxt" class="code mono" spellcheck="false"></textarea>
      <div class="row">
        <button class="btn" id="btnApply">Apply</button>
        <button class="btn" id="btnReset">Reset</button>
      </div>
      <div class="mono muted">pareto.tau=0.55 • quality.q=1.00 • intent.axis=radial|x|y • intent.strength=1.20 • art.nu=3 • art.points=260 • lockon.k=6 • mood.strength=1.0</div>
    </div>

    <div class="legend">
      <span class="pill blue">ART t-field</span>
      <span class="pill green">Lock-on</span>
      <span class="pill purple">Infosophic ⇄ Simulonic</span>
      <span class="pill gold">ds² gauges</span>
      <span class="pill pos">Optimistic</span>
      <span class="pill neg">Pessimistic</span>
    </div>

    <div class="stats" id="statsBox">
      <div class="statLine"><span class="muted">ds² (Green)</span><span class="mono" id="statG">0.000</span></div>
      <div class="statLine"><span class="muted">ds² (Vacuum)</span><span class="mono" id="statV">0.000</span></div>
      <div class="statLine"><span class="muted">Locked</span><span class="mono" id="statL">0</span></div>
      <div class="statLine"><span class="muted">Pareto τ</span><span class="mono" id="statT">0.00</span></div>
      <div class="statLine"><span class="muted">Optimistic</span><span class="mono" id="statPos">0</span></div>
      <div class="statLine"><span class="muted">Pessimistic</span><span class="mono" id="statNeg">0</span></div>
    </div>

    <!-- Lens HUD -->
    <div class="lensHUD">
      <button class="btn" id="btnLensMode">Lens: Infosophic (I)</button>
      <span class="muted">Radius</span>
      <input id="rngLensR" type="range" min="60" max="360" step="2" style="width:220px">
      <span class="mono" id="labLensR">180</span>
      <span class="muted">Drag the circle • Press S to switch to Simulonic</span>
    </div>
  </div>

<script>
/* ---------- Sizing ---------- */
const stage = document.getElementById('stage');
const wrap = document.getElementById('stageWrap');
function fitCanvas(){
  const headerH = document.querySelector('header').offsetHeight || 64;
  wrap.style.height = `calc(100vh - ${headerH}px)`;
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  stage.width = Math.floor(wrap.clientWidth * dpr);
  stage.height = Math.floor(wrap.clientHeight * dpr);
  stage.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvas, {passive:true});
fitCanvas();

/* ---------- RNG + math ---------- */
function rng(seed){ let t = seed>>>0; return ()=>{ t += 0x6D2B79F5; let r = Math.imul(t ^ (t>>>15), 1|t); r ^= r + Math.imul(r ^ (r>>>7), 61|r); return ((r ^ (r>>>14))>>>0)/4294967296; }; }
function randn(r){ let u=1-r(), v=1-r(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function chiSquare(df, r){ let s=0; for(let i=0;i<df;i++){ const z=randn(r); s += z*z; } return s; }
function studentT(df, r){ const z=randn(r); return z / Math.sqrt(chiSquare(df,r)/df); }
function softmax(arr, temp=1){ const m=Math.max(...arr); const ex=arr.map(v=>Math.exp((v-m)/Math.max(1e-6,temp))); const s=ex.reduce((a,b)=>a+b,0); return ex.map(e=>e/s); }

/* ---------- SimuLang ---------- */
const defaultSimuLang = `# SimuLang mini-hook
pareto.tau = 0.55
quality.q = 1.00
intent.axis = radial
intent.strength = 1.20
art.nu = 3
art.points = 260
lockon.k = 6
mood.strength = 1.0
`;
function parseSimuLang(src){
  const cfg = { paretoTau:0.55, qualityQ:1.0, intentAxis:'radial', intentStrength:1.2, artNu:3, artPoints:260, lockTopK:6, moodStrength:1.0 };
  const lines = src.split('\n').map(s=>s.trim()).filter(Boolean);
  for(const l of lines){
    const m = l.match(/^([a-z.]+)\s*=\s*([^\#]+)(?:\#.*)?$/i); if(!m) continue;
    const k=m[1].toLowerCase().trim(), v=m[2].trim();
    if(k==='pareto.tau') cfg.paretoTau = parseFloat(v);
    if(k==='quality.q') cfg.qualityQ = parseFloat(v);
    if(k==='intent.axis') cfg.intentAxis = (''+v).toLowerCase();
    if(k==='intent.strength') cfg.intentStrength = parseFloat(v);
    if(k==='art.nu') cfg.artNu = Math.max(1, parseInt(v));
    if(k==='art.points') cfg.artPoints = Math.max(10, Math.min(5000, parseInt(v)));
    if(k==='lockon.k') cfg.lockTopK = Math.max(0, parseInt(v));
    if(k==='mood.strength') cfg.moodStrength = Math.max(0, parseFloat(v));
  }
  return cfg;
}

/* ---------- Outlooks ---------- */
const DIMENSIONS = ['Creed','Race','Class','Caste','Tribe','Nationality','Continentality','Planetarity','Occupation'];
let outlook = Object.fromEntries(DIMENSIONS.map(d => [d, +1]));
function hueForDim(i){ return (i*37)%360; }

/* ---------- State ---------- */
let seed = 42;
let cfg = parseSimuLang(defaultSimuLang);
let lockSet = new Set();
let points=[], weights=[];
const ctx = stage.getContext('2d');

/* ---------- Elements ---------- */
const E = {
  tau: rngTau, q: rngQ, intent: rngIntent, axis: selAxis, nu: rngNu, pts: rngPts, mood: rngMood,
  labTau, labQ, labIntent, labNu, labPts, labMood,
  statG, statV, statL, statT, statPos, statNeg,
  simTxt: simTxt, btnApply, btnReset, btnShuffle, btnClear,
  outlookGrid: outlookGrid,
  btnLensMode: btnLensMode, rngLensR: rngLensR, labLensR: labLensR
};
E.simTxt.value = defaultSimuLang;

/* ---------- Lens (draggable x-ray) ---------- */
const lens = {
  x: stage.clientWidth/2,
  y: stage.clientHeight/2,
  r: 180,
  mode: 'infosophic', // 'infosophic' | 'simulonic'
  dragging: false,
  offsetX: 0, offsetY: 0
};
E.rngLensR.value = lens.r; E.labLensR.textContent = lens.r;

function setLensMode(next){
  lens.mode = next;
  E.btnLensMode.textContent = next==='infosophic' ? 'Lens: Infosophic (I)' : 'Lens: Simulonic (S)';
}
E.btnLensMode.addEventListener('click', ()=>{
  setLensMode(lens.mode==='infosophic' ? 'simulonic' : 'infosophic');
});
document.addEventListener('keydown', (e)=>{
  if(e.key==='i' || e.key==='I') setLensMode('infosophic');
  if(e.key==='s' || e.key==='S') setLensMode('simulonic');
});
E.rngLensR.addEventListener('input', (e)=>{
  lens.r = parseInt(e.target.value,10); E.labLensR.textContent = lens.r;
});

stage.addEventListener('mousedown', (e)=>{
  const rect = stage.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  const dx=x-lens.x, dy=y-lens.y; if(Math.hypot(dx,dy) <= lens.r){ lens.dragging=true; lens.offsetX=dx; lens.offsetY=dy; }
});
window.addEventListener('mouseup', ()=>{ lens.dragging=false; });
window.addEventListener('mousemove', (e)=>{
  if(!lens.dragging) return;
  const rect = stage.getBoundingClientRect(); let x=e.clientX-rect.left, y=e.clientY-rect.top;
  lens.x = x - lens.offsetX; lens.y = y - lens.offsetY;
});

/* ---------- UI wiring ---------- */
function syncControls(){
  E.tau.value = cfg.paretoTau; E.labTau.textContent = cfg.paretoTau.toFixed(2);
  E.q.value = cfg.qualityQ; E.labQ.textContent = cfg.qualityQ.toFixed(2);
  E.intent.value = cfg.intentStrength; E.labIntent.textContent = cfg.intentStrength.toFixed(2);
  E.axis.value = cfg.intentAxis;
  E.nu.value = cfg.artNu; E.labNu.textContent = cfg.artNu;
  E.pts.value = cfg.artPoints; E.labPts.textContent = cfg.artPoints;
  E.mood.value = cfg.moodStrength; E.labMood.textContent = cfg.moodStrength.toFixed(2);
  E.statT.textContent = cfg.paretoTau.toFixed(2);
}
syncControls();

function buildOutlookGrid(){
  E.outlookGrid.innerHTML = '';
  DIMENSIONS.forEach((d,i)=>{
    const label = document.createElement('div');
    const sw = document.createElement('span'); sw.className='swatch'; sw.style.background = `hsl(${hueForDim(i)} 80% 60%)`;
    label.appendChild(sw); label.appendChild(document.createTextNode(d));
    const btn = document.createElement('button');
    const isPos = outlook[d]>=0; btn.className='toggle ' + (isPos?'pos':'neg'); btn.textContent=isPos?'Optimistic':'Pessimistic';
    btn.title = `Toggle outlook for ${d}`;
    btn.addEventListener('click', ()=>{ outlook[d]=(outlook[d]>=0)?-1:+1; buildOutlookGrid(); buildART(); });
    E.outlookGrid.appendChild(label); E.outlookGrid.appendChild(btn);
  });
}
buildOutlookGrid();

/* ---------- Field generation ---------- */
function buildART(){
  const r = rng(seed);
  const W=stage.clientWidth, H=stage.clientHeight, cx=W/2, cy=H/2, scale=Math.min(W,H)*0.33;
  points=[]; let pos=0, neg=0;
  for(let i=0;i<cfg.artPoints;i++){
    const dim = DIMENSIONS[i % DIMENSIONS.length];
    const tx=studentT(cfg.artNu,r), ty=studentT(cfg.artNu,r);
    const x=cx+scale*tx, y=cy+scale*ty;
    const dx=x-cx, dy=y-cy, rad=Math.hypot(dx,dy)/(scale+1e-6);
    let align=0; if(cfg.intentAxis==='x') align=Math.abs(dx)/(scale+1e-6); else if(cfg.intentAxis==='y') align=Math.abs(dy)/(scale+1e-6); else align=Math.max(0,1-rad);
    const base = 1/(1 + (dx*dx+dy*dy)/(scale*scale));
    const mood = outlook[dim]||+1;
    const moodGain = 1 + cfg.moodStrength*(mood*0.25);
    const sal = base * (1 + cfg.intentStrength*align) * moodGain;
    if(mood>=0) pos++; else neg++;
    points.push({x,y,sal,dim,mood});
  }
  const maxS = points.reduce((m,p)=>Math.max(m,p.sal),1e-6);
  for(const p of points){ p.sal/=maxS; }
  weights = softmax(points.map(p=>p.sal), Math.max(0.05,cfg.paretoTau));
  // auto top-K lock-ons
  if(cfg.lockTopK>0){
    const top=[...points.map((p,i)=>[p.sal,i])].sort((a,b)=>b[0]-a[0]).slice(0,cfg.lockTopK).map(x=>x[1]);
    for(const i of top) lockSet.add(i);
  }
  E.statPos.textContent = pos; E.statNeg.textContent = neg;
}
buildART();

/* ---------- Gauges (global) ---------- */
function computeDS2Dual(lockedIdx){
  if(points.length===0) return {g:0,v:0};
  let active = lockedIdx.length ? lockedIdx : [...points.map((p,i)=>[p.sal,i])]
    .sort((a,b)=>b[0]-a[0]).slice(0, Math.max(3, Math.floor(points.length*0.05))).map(x=>x[1]);
  const K = (a,b)=>{ const dx=a.x-b.x, dy=a.y-b.y, d2=dx*dx+dy*dy; return Math.exp(-d2/3000); };
  const G = (a,b)=>{ const dx=a.x-b.x, dy=a.y-b.y; return 1/(Math.hypot(dx,dy)+1e-3); };
  const Qn = cfg.qualityQ;
  let dsG=0, dsV=0;
  for(const i of active){
    for(let j=0;j<points.length;j++){
      const wi=weights[i]/Qn, wj=weights[j]/Qn;
      dsG += wi*wj*K(points[i], points[j]);
      dsV += wi*wj*G(points[i], points[j]);
    }
  }
  const squash = v => 1 - Math.exp(-v/50);
  return { g: squash(dsG), v: squash(dsV) };
}

/* ---------- Lens rendering helpers ---------- */
/* Fast local “x-ray”: score each point by kernel-with-center only (O(n)), clip to circle. */
function lensScores(){
  const cx=lens.x, cy=lens.y, r=lens.r;
  const useK = (a)=>Math.exp(-((a.x-cx)**2 + (a.y-cy)**2)/3000);     // Green-ish
  const useG = (a)=>1/(Math.hypot(a.x-cx, a.y-cy)+1e-3);            // inverse-gradient
  const kernel = lens.mode==='infosophic' ? useK : useG;

  let scores = new Float32Array(points.length);
  let sum=0;
  for(let i=0;i<points.length;i++){
    const p=points[i]; const dx=p.x-cx, dy=p.y-cy; const inside = (dx*dx+dy*dy)<=r*r;
    if(!inside) { scores[i]=0; continue; }
    const s = (weights[i]/Math.max(0.5,cfg.qualityQ)) * kernel(p);
    scores[i]=s; sum += s;
  }
  // normalize for color scale and a local ds² readout
  const maxScore = Math.max(1e-6, ...scores);
  for(let i=0;i<scores.length;i++) scores[i]/=maxScore;
  // pseudo local ds² (squashed total intensity)
  const dsLocal = 1 - Math.exp(-sum/20);
  return {scores, dsLocal};
}

function drawLensOverlay(scores){
  const r=lens.r, cx=lens.x, cy=lens.y;
  // Clip to circle
  ctx.save();
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.clip();

  // Subtle darken background inside lens
  ctx.fillStyle = 'rgba(0,0,0,.25)';
  ctx.fillRect(cx-r-2, cy-r-2, r*2+4, r*2+4);

  // Heat overlay for points inside lens
  for(let i=0;i<points.length;i++){
    const s=scores[i]; if(s<=0) continue;
    const p=points[i];
    // color ramp: Infosophic → cyan/blue, Simulonic → gold/orange
    let col;
    if(lens.mode==='infosophic'){
      const a=.25 + .55*s; col = `hsla(195, 90%, 60%, ${a})`; // teal
    }else{
      const a=.25 + .55*s; col = `hsla(40, 95%, 60%, ${a})`;  // amber
    }
    ctx.beginPath(); ctx.fillStyle=col; ctx.arc(p.x, p.y, 2 + 3*s, 0, Math.PI*2); ctx.fill();
  }

  // Inner ellipse = local ds² readout
  const {dsLocal} = lensScores(); // recompute tiny scalar (cheap)
  ctx.strokeStyle = lens.mode==='infosophic' ? 'rgba(97,218,251,.9)' : 'rgba(251,191,36,.9)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.ellipse(cx, cy, 40*(.6+.8*dsLocal), 40*(.6+.8*dsLocal), 0, 0, Math.PI*2); ctx.stroke();

  ctx.restore();

  // Lens rim + label
  ctx.beginPath();
  ctx.lineWidth = 2.2;
  ctx.setLineDash([6,4]);
  ctx.strokeStyle = lens.mode==='infosophic' ? 'rgba(97,218,251,.9)' : 'rgba(251,191,36,.9)';
  ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = 'rgba(16,20,30,.85)';
  ctx.strokeStyle = '#27304a';
  ctx.lineWidth = 1;
  const label = lens.mode==='infosophic' ? 'Infosophic lens (∇⁻¹)' : 'Simulonic lens (∇¹)⁻¹';
  const metrics = lensScores();
  const text = `${label}  •  r=${r}  •  local ds²=${metrics.dsLocal.toFixed(3)}`;
  ctx.font = '12px ui-monospace';
  const w = ctx.measureText(text).width + 12, h=20;
  ctx.beginPath(); ctx.roundRect(cx - w/2, cy - r - 28, w, h, 6); ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#cfe8ff';
  ctx.fillText(text, cx - w/2 + 6, cy - r - 14);
}

/* ---------- Render loop ---------- */
function render(){
  const W=stage.clientWidth, H=stage.clientHeight;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='#0f131d'; ctx.fillRect(0,0,W,H);

  // grid
  ctx.strokeStyle='rgba(70,90,130,.35)'; ctx.lineWidth=1;
  const step=40;
  for(let x=0;x<W;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // global gauges
  const lockedIdx=[...lockSet];
  const ds=computeDS2Dual(lockedIdx);
  const cx=W/2, cy=H/2;
  ctx.strokeStyle='rgba(159,122,234,.85)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.ellipse(cx, cy, 120*(.6+.6*ds.g), 120*(.6+.6*ds.v), 0, 0, Math.PI*2); ctx.stroke();

  // points
  let posCount=0, negCount=0;
  for(let i=0;i<points.length;i++){
    const p=points[i];
    const w=weights[i]||0;
    const r=2+4*w;
    const locked=lockSet.has(i);
    const dimIdx = DIMENSIONS.indexOf(p.dim);
    const baseHue = (dimIdx*37)%360;
    const hue = (p.mood>=0)? (baseHue*0.7 + 120*0.3) : (baseHue*0.7 + 0*0.3);
    const alpha = 0.6 + 0.35*w;
    ctx.beginPath();
    ctx.fillStyle = locked ? `hsl(160 90% 60% / .95)` : `hsl(${hue} 80% 60% / ${alpha})`;
    ctx.strokeStyle = locked ? 'rgba(110,231,166,.85)' : (p.mood>=0 ? 'rgba(110,231,166,.35)' : 'rgba(248,113,113,.35)');
    ctx.lineWidth = locked ? 1.6 : 1;
    ctx.arc(p.x,p.y,r*(locked?1.3:1.0),0,Math.PI*2); ctx.fill(); ctx.stroke();
    if(locked){
      ctx.beginPath(); ctx.setLineDash([4,4]); ctx.strokeStyle='rgba(110,231,166,.3)';
      ctx.arc(p.x,p.y,r*2.0,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
    }
    if(p.mood>=0) posCount++; else negCount++;
  }

  // lens overlay (after base points)
  const {scores} = lensScores();
  drawLensOverlay(scores);

  // stats
  E.statG.textContent = ds.g.toFixed(3);
  E.statV.textContent = ds.v.toFixed(3);
  E.statL.textContent = lockSet.size;
  E.statPos.textContent = posCount;
  E.statNeg.textContent = negCount;

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/* ---------- Interaction ---------- */
stage.addEventListener('click', (e)=>{
  const rect=stage.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  // if click inside lens, do not toggle lock (just move via drag); otherwise lock nearest
  const inside = Math.hypot(x-lens.x, y-lens.y) <= lens.r;
  if(inside) return;
  let best=-1, bd=1e9;
  for(let i=0;i<points.length;i++){
    const dx=points[i].x-x, dy=points[i].y-y, d=dx*dx+dy*dy; if(d<bd){ bd=d; best=i; }
  }
  if(best>=0){ if(lockSet.has(best)) lockSet.delete(best); else lockSet.add(best); }
});

/* ---------- Control events ---------- */
E.tau.addEventListener('input', e=>{ cfg.paretoTau=parseFloat(e.target.value); E.labTau.textContent=cfg.paretoTau.toFixed(2); E.statT.textContent=cfg.paretoTau.toFixed(2); weights=softmax(points.map(p=>p.sal), Math.max(0.05,cfg.paretoTau)); });
E.q.addEventListener('input', e=>{ cfg.qualityQ=parseFloat(e.target.value); E.labQ.textContent=cfg.qualityQ.toFixed(2); });
E.intent.addEventListener('input', e=>{ cfg.intentStrength=parseFloat(e.target.value); E.labIntent.textContent=cfg.intentStrength.toFixed(2); buildART(); });
E.axis.addEventListener('change', e=>{ cfg.intentAxis=e.target.value; buildART(); });
E.nu.addEventListener('input', e=>{ cfg.artNu=parseInt(e.target.value,10); E.labNu.textContent=cfg.artNu; buildART(); });
E.pts.addEventListener('input', e=>{ cfg.artPoints=parseInt(e.target.value,10); E.labPts.textContent=cfg.artPoints; lockSet.clear(); buildART(); });
E.mood.addEventListener('input', e=>{ cfg.moodStrength=parseFloat(e.target.value); E.labMood.textContent=cfg.moodStrength.toFixed(2); buildART(); });

E.btnShuffle.addEventListener('click', ()=>{ seed=(seed*1664525+1013904223)>>>0; lockSet.clear(); buildART(); });
E.btnClear.addEventListener('click', ()=>{ lockSet.clear(); });

E.btnApply.addEventListener('click', ()=>{ const parsed=parseSimuLang(E.simTxt.value); cfg={...cfg,...parsed}; syncControls(); lockSet.clear(); buildART(); });
E.btnReset.addEventListener('click', ()=>{ E.simTxt.value=defaultSimuLang; cfg=parseSimuLang(E.simTxt.value); syncControls(); lockSet.clear(); buildART(); });

/* ---------- Outlook grid init ---------- */
</script>
</body>
</html>
